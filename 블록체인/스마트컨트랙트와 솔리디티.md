이더리움은 외부 소유 계정 (EOA) 와 컨트랙트 계정 이라는 2가지 유형의 계정이 존재한다.

EOA는 지갑 어플리케이션이, 컨트랙트는 이더리움 가상 머신이 제어한다.

컨트랙트 계정은 개인키를 갖지 않고, 미리 정의된 방식으로 스스로 동작한다. EOA는 프로토콜에 독립적인 개인키를 생성하고 서명으로 제어된다.

두가지 유형 모두 이더리움 주소로 식별된다.

1. 스마트컨트랙트란?

당사자들끼리 합의된 약속에 따라 수행되는 디지털 형식의 약속

2. 스마트컨트랙트의 생명주기

a. 스마트컨트랙트를 실행하기 위해선 EVM에서 바이너리 코드로 컴파일 되어있어야 한다.
b. 컴파일되면 컨트랙트 생성 트랜잭션을 타고 제로 어드레스로 이더리움 플랫폼에 배포된다.
c. 컨트랙트는 이더리움 주소로 식별된다.
d. 스마트 컨트랙트는 키가 없다. 컨트랙트 사용자는 프로토콜 수준에서 특별 권한을 얻지 못한다.

컨트랙트는 트랜잭션에 의해 호출된 경우에만 실행된다.

컨트랙트는 다른 컨트랙트를 호출하는것도 가능하다.

트랜잭션은 원자성의 특징을 지닌다. (모든 실행이 성공적으로 종료된 경우에만 글로벌 상태의 변경사항이 기록되고 종료된다. 오류가 생기면 롤백된다.)

컨트랙트를 삭제할려면 SELFDESTRUCT EVM 연산코드를 실행해야한다.

스마트 컨트랙트는 솔리디티로 만든다.

솔리디티 컴파일러는 solc이다. 

3. 솔리디티 버전 선택

pragma라는 지시자로 먼저 버전을 솔리디티 버전을 선택해줘야한다.

ex) pragma solidity ^0.5.11;

ABI(Application Binary Interface) : EVM에서 컨트랙트를 호출 인코딩하고 트랜잭션 데이터를 읽는데 사용됨

type,name,inputs,outputs,constant,payable 필드가 있는 JSON 객체로 인코딩된다.

ABI를 사용하여 지갑,댑 같은 애플리케이션이 스마트 컨트랙트의 함수를 호출하는 트랜잭션을 생성할 수 있다.

애플리케이션이 컨트랙트와 상호작용 하기 위해서는 ABI와 컨트랙트 배포 주소가필요하다.

4. 솔리디티로 프로그래밍하기

솔리디티의 타입
부울 : bool, 정수 : int uint
고정소수점 : fixed ufiex
주소 : address객체 20바이트 이더리움 주소를 가지고 있음. 멤버 함수로 balance(계정 잔액 반환) transfer(이더 전송) 등이 있음.
바이트 배열 : bytes1~bytes32까지 고정 크기 바이트배열이 있음
바이트 배열(가변) : bytes,string 
열거형 : enum
배열 : C와 동일함
구조체 : struct (변수 그룹화를 위한 사용자 데이터 컨테이너 C와 동일)
매핑 : 키=>쌍 저장을 위한 해시 조회 테이블 ex) mapping(KEY_TYPE=>VALUE_TYPE) MappingName (키타입과 값타입을 지정해줘야함)

시간 단위 (time units) : seconds,minutes,hours,days 
이더 단위 : wei, finney, szabo, ether

5. 사전 정의된 글로벌 변수와 함수들.
대표적으로 block,msg,tx객체가 있다.

5.1 msg객체
컨트랙트 실행을 시작한 트랜잭션 호출, 메시지 호출등의 기능을 가지고 있다.

msg.sender : 컨트랙트를 호출한 발신자의 주소, 컨트랙트가 다른 컨트랙트를 호출했을 경우엔 컨트랙트의 주소가 된다.

msg.value : 호출과 함께 전송된 이더의 값

msg.gas : 컨트랙트 실행 환경에서 사용하고 남은 가스의 양. gasleft 함수로 대체되었다.

msg.data : 데이터 페이로드

msg.sig : 함수 선택자 페이로드 (significant)

5.2 tx(트랜잭션 컨텍스트 객체)

tx : 트랜잭션 관련 정보에 접근하는 방법 제공

tx.gasprice : 트랜잭션을 호출하는 데 필요한 가스 가격
tx.origin : 원래 EOA 주소

5.3 블록컨텍스트 block

block 객체는 현재 블록에 대한 정보가 포함되어있음
block.blockhash(blockNumber)

지정된 블ㄹ록 번호의 블록 해시. blockhash()함수로 대체되었음

block.coinbase 현재 블록 수수료 및 보상 수취인 주소

block.difficulty 현재 블록 난이도

block.gaslimit 모든 트랜잭션에 소요될 가스의 양

block.number 현재 블록 번호

block.timestamp 채굴자가 현재 블록에 넣은 타임스탬프.

5.4 address 객체

입력으로 전달되거나 컨트랙트 객체에서 형변환되는 모든 주소에는 다음과 같은 많은 속성과 메서드가 존재한다.

address.balance : 웨이로 표현된 주소의 잔액, 현재 컨트랙트 잔액은 address(this).balance이다.

address.transfer(amount) : 주소로 금액을 전송시킨다. msg.sender.transfer와 같다.

address.send(amount) : transfer와 같지만 예외 발생하면 false를 일으킨다.

address.call(payload) : 저수준 call 함수, 오류가 발생하면 false

address.callcode(payload) : address.call 과 같지만 컨트랙트 코드 주소가 주소의 코드로 대체됨. (먼소리징)

address.delegatecall() : callcode와 같지만 현재 컨트랙트에서 볼 수 있는 전체 msg 컨텍스트가 있는 콜 함수. 

5.5 내장함수들

addmod, mulmod : addmod(x,y,k) => (x+y)%k

keccak256,sha256,sha3,ripemd160

ecrecover : 서명에서 메시지 서명에 사용된 주소 복구

selfdestrunct(recipient_address) : 현재 컨트랙트 삭제, 나머지 이더는 환불

this : 현재 실행중인 컨트랙트 계정 주소.

6. 컨트랙트 정의

contract로 시작 자바 클래스와 유사하다.

interface 객체 : 함수가 정의되어 있지 않고 선언만 되어있음. 나머지는 컨트랙트와 유사한 구조. 이런 선언을 stub이라고 부른다.인터페이스는 컨트랙트의 형태를 저장하고 

상속될때 자식에 의해서 정의되어야 한다.

library  : 라이브러리 컨트랙트는 delegatecall 를 사용하여 한 번만 배포되고 다른 컨트랙트에서 사용되기 위한 컨트랙트.

7. 함수

function functionName([parameters]) {public|private|internal|external} [pure|constant|view|payable] 
[modifiers] [returns]

fallback(이름이 없는 기본 함수)

public : 공개 함수값, 다른 컨트랙트나 EOA에서 이 함수를 호출하는것이 가능하다.

external : 외부 함수, 외부함수에선 호출이 가능하지만, 컨트랙트에선 불가능하다.

internal : 내부 컨틀랙트에서 호출 가능. 다른 컨트랙트 , 다른 컨트랙트,EOA는 호출불가. 파생된 호출 가능

private : 패상된 컨트랙트에서조차도 호출 불가.

constant , view : view 는 상태변경을 하지 않고 보기만 함.
constant : 향후 릴리스에서 사용되지 않는 뷰의 별칭. constant를 쓰는것을 추천

pure : 스토리지에서 변수를 읽거나 쓰지 않는 함수, view는 읽지만 pure는 읽는것 조차 하지 않는다.