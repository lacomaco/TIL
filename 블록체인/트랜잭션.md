EOA (외부 소유 계정) 에 의해 서명된 메시지.
이더리움 네트워크에 의해 전송되고 이더리움 블록체인에 기록이된다.

트랜잭션은 EVM에서 상태 변화를 일으킬 수 있는 유일한 방법.

1. 트랜잭션 구조

논스 , 가스 가격, 가스한도,수신자,값,데이터,vrs(EOA의 ECDSA 디지털 서명 3가지 요소) 정보를 담은 트랜잭션이 바이너리로 시리얼라이즈 되어서 네트워크나 클라이언트에게 전송된다.

모드 RLP로 인코딩되어 시리얼라이즈된다. 지갑에서 볼 수 있는 필드의 이름은 지갑 자체에서 추가한것이다.

v,r,s 같은경우 ECDSA 서명 구성 요소로 이를 통해서 공개키의 주소를 알아낼 수 있다.

지갑에서 발신자가 표시되는것은 v,r,s를 통해서 발신원을 알아내서 소프트웨어가 추가한것이다.

2. 트랜잭션 논스

논스 : 해당 주소에서 보낸 트랜잭션 수. 계정에서 만든 트랜잭션의 수 블록체인 계정 상태에는 저장되지 않는다.

논스의 중요성
a. 탈중앙화 되어있기 때문에 노드에서 보낸 여러개의 트랜잭션이 뒤죽박죽 섞여서 들어올 수 있다. 이 때 논스를 통해서 정렬하여 트랜잭션을 검토할 수 있다.
b. 지급 금액을 복제하는것을 논스를 통해서 방지할 수 있다.

3. 논스 추적
논스 ( 각 계정에서 발생한 체인상의 트랜잭션 수에 대한 최신 통계)
web3.eth.getTransactionCount()로 해당 지갑에서 발생한 트랜잭션 수를 볼 수 있다.
주목해야할점은 논스는 체인상에 기록된 트랜잭션만 취급한다.

4. 논스 간격, 중복 논스 확인

이더리움은 논스를 순차적으로 처리한다.

만약 논스 0인 트랜잭션이 전송되고 곧바로 논스2가 전송되면

논스 2는 처리되지 않고 우선 mempool에 저장되며 논스 0,1 이 처리될떄까지 대기상태에 놓인다. 그후 2가 순차적으로 처리된다.

트랜잭션은 회수되지 않는다. 논스가 중복된 트랜잭션이 호출되면 하나 빼고 모두 리젝된다. 무작위로 결정된다.

5. 동시실행,트랜잭션 생성 및 논스

이더리움은 동시실행을 허용하되 합의로 이를 하나로 강제하는 싱글톤 시스템이다.

핫월랫 같이 온라인에서 키가 저장된 지갑에서 출금을 생각해보자.

이상적으론 병렬로 2대 이상의 컴퓨터가 출급 작업을 처리하도록 하는것이 좋은데 그렇게 되면 동시 실행문제가 발생한다.

책에선 해결하는 방법을 2개를 놨다.

우선 단일 컴퓨터를 활용해서 트랜잭션을 놓는법,

출금 작업을 처리하는 컴퓨터에서 트랜잭션을 생성하지만 논스는 할당하지 않고, 이 트랜잭션들을 노드 대기열에 올려 트랜잭션을 순차적으로 서명하고 논스를 관리하는 방법이다.

이렇게 되면 2가지 일을 병렬로 처리하고 다시 1개의 노드가 직렬로 처리하기 때문에 병렬이 발생한다.

6. 트랜잭션 가스

가스 (이더리움의 연료): 채굴자에게 돌아가는 일종의 수고비

가스는 이더가 아닌 자체 환율을 지닌 화폐이다.

트랜잭션내 gasPrice 필드는, 트랜잭션 생성자가 지급할 가격을 설정한다.

gasPrice가 높을수록 트랜잭션은 더 빨리 컨펌된다.

gasLimit : 트랜잭션 사용자가 지정할 수 있는 최대 가스 단위.

지급할 가스의 양은 트랜잭션이 블록에 포함되기 전에 얼마나 많은 다른 트랜잭션이 해당 기능을 호출했는지에 따라 다르다.

따라서 이더리움은 트랜잭션을 반영하기 전에 먼저 트랜잭션을 모두 완료할 가스가 있는지 체크한다.

트랜잭션이 완료되면 가스를 차감한다. 트랜잭션을 완료할 충분한 가스를 소유하고 있어야 한다.

7. 트랜잭션 수신자

20바이트 이더리움 주소 (EOA나 컨트랙트 주소일수도 있음)

8. 트랜잭션 값,데이터

트랜잭션은 값,데이터를 가지거나 가지지 않는 4가지 조합으로 보낼 수 있다.

값만 있는 경우엔 금액을 지급하는 경우이고

데이터만 가는 경우엔 호출하는 경우이다.

web3.eth.sendTransaction으로 보낼 수 있다.

9. EOA,Contract에 값 전달
EOA 주소로 값이 전달되는 경우엔 이더리움은 상태 변경을 기록하여 주소 로 값을 추가한다.

컨트랙트로 호출되는 경우엔
EVM은 컨트랙트를 실행하고 데이터 페이로드에 지정된 함수를 호출 시도한ㄴ다.

데이터가 없다면 fallback 함수를 호출하고, 해당 함수가 지급가능하다면 값을 넣는다. 

폴백함수가 없다면 EOA처럼 컨트랙트에 잔액을 넣는다.

그후 컨트랙트 상태를 블록에 반영한다.

컨트랙트는 예외 처리를 통해 입금 거부하는것이 가능하다.

10. EOA,Contract에 데이터 페이로드 전달

EOA의 경우 지갑 어플리케이션이 데이터를 어떻게 처리하는지에 따라 다르다. 보통은 데이터를 무시한다.

컨트랙트의 경우 EVM에서 컨트랙트 호출로 인식하여 해당 컨트랙트를 호출한다. ( 함수 호출 )

그리고 인코딩된 인수를 함수에 넣어 실행시킨다.

데이터 페이로드는 함수 선택기 (keccak-256으로 함수 프로토타입을 해싱한것)
함수 인수 (ABI 사양에 맞춰 인코딩된 인수)
둘을 시리얼라이즈하여 보낸다.

예를들어 컨트랙트에 

function withdraw(uint temp) public ....

이런 함수가 있다면

함수 선택기는 프로토타입인 withdraw(uint) 를 keccak-256으로 해싱한후, 처음 4바이트를 잘라낸값이다.
함수 인수는 만약 우리가 0.01 either를 보내고 싶다면 이를 Wei로 환산
그후 16진수(Hex)로 변경하여

함수 선택기 뒤에 붙이면된다.

11. 특별한 트랜잭션 : 컨트랙트 생성

컨트랙트 생성은 제로 어드레스라고 부르는 특수 대상 주소로 전송된다. 0x0000000...00이 제로 어드레스이다.

그렇다고 이것이 컨트랙트를 나타내는것은 아니다. 그저 목적지일 뿐이다.

컨트랙트 생성 트랜잭션은 컴파일할 컨트랙트를 생성할 컴파일된 바이트코드를 포함하는 데이터 페이로드를 포함해야된다.

12. 디지털 서명

디지털 서명의 용도
A. 이더리움 계정과 개인키 소유자가 이더 지출, 컨트랙트 이행 승인 했음을 증명
B. 부인 방지 보장
C. 트랜잭션 수정 불가능을 증명.

디지털 서명은 수학적 체계에 기인하여 동작한다.

ECDSA에서 서명된 메시지는 keccak-256 해싱된 트랜젝션이다.

서명키는 EOA의 개인키이다.

Sig(서명결과) = F(sig) (F(keccak256)(m),k);

F(sig)=>서명 알고리즘
F(keccak256)=>해싱함수.
m=>RLP인코딩된 트랜잭션
k=>개인키

서명괄과는 서명 알고리즘에 인자로 RLP인코딩된 트랜잭션을 keccak256 해싱함수로 해싱한 값과, EOA개인키를 넣어 나온 결과값이라고 이해하면 될것 같다.

13. 서명확인

서명 확인에는 서명, 시리얼라이즈된 트랜잭션, 서명을 만드는데 사용한 개인키에 대응되는 공개키로 서명을 확인한다.

공개키로 서명을 역 해싱할 수 있기 때문에 가능하다.

서명 r s를 구하는 방법.

서명 s값을 구하는 방법

s= q^-1(Keccak256(m)+r*k) (mod p)
q=>일시적 개인키
r=>일시적 공개키의 x좌표
k 서명 개인키
m 트랜잭션 데이터
p 타원곡선 소수차수

서명값 s는 트랜잭션을 keccak256 해시한값에 일시적 공개키의 x좌표와 서명 개인키를 곱한값을 일시적 개인키에 넣고 역수를 취한ㄴ후 타원곡순 차수로 나눈 나머지값이다.

검증은 서명 생성함수의 역수이다.

Q=>타원 곡선 지점값

Q=u1*_G+u2*K*(mod p)

r과 s는 서명값
K는 서명자의 공개키
m은 트랜잭션 데이터
G는 타원곡선 생상저 점
p는 타원 곡선 소수 차수.

Q의 x좌표가 서명 r과 같으면 서명이 유효하다.

14. 트랜잭션 서명

이더리움에서 트랜잭션을 사용하기 위해선 다음 과정을 거쳐야한다.

a. nonce,gasPrice,gasLimit,to,value,data,chainID,0,0 9개 필드를 포함하는 트랜잭션 구조를 만든다.
b. RLP로 인코딩된 트랜잭션 데이터 구조의 시리얼라이즈된 메시지 생성
c. keccak-256 해시 계산
d. EOA 개인키로 해시서명, ECDSA 서명 계산
e. ECDSA 서명의 계산된 v,r,s를 트랜잭션에 추가.

같은 과정을 반드시 거쳐야한다.

v는 특수 서명변수이다. ECDSArecover 함수가 서명을 확인하는데 도움이 되는 복구 식별자와 체인 ID를 의미한다.

체인 ID에 2를 곱한후 35,36을 더해 계산한다. 

트랜잭션은 ethereumjs-tx 라이브러릴를 사용하면 된다.

```js
// Load requirements first:
//
// npm init
// npm install ethereumjs-tx
//
// Run with: $ node raw_tx_demo.js
const ethTx = require('ethereumjs-tx');

//트랜잭션 데이터 구조
//from이 없다. ECDSA 서명을 통해 직접계산이 가능하기 때문에 발신원이 없다.
const txData = {
  nonce: '0x0',
  gasPrice: '0x09184e72a000',
  gasLimit: '0x30000',
  to: '0xb0920c523d582040f2bcb1bd7fb1c7c1ecebdb34',
  value: '0x00',
  data: '',
  v: "0x1c", // Ethereum mainnet chainID
  r: 0,
  s: 0 
};

tx = new ethTx(txData);
console.log('RLP-Encoded Tx: 0x' + tx.serialize().toString('hex'))

txHash = tx.hash(); // This step encodes into RLP and calculates the hash
console.log('Tx Hash: 0x' + txHash.toString('hex'))

// Sign transaction
const privKey = Buffer.from(
    '91c8360c4cb4b5fac45513a7213f31d4e4a7bfcb4630e9fbf074f42a203ac0b9', 'hex');
tx.sign(privKey);

serializedTx = tx.serialize();
rawTx = 'Signed Raw Transaction: 0x' + serializedTx.toString('hex');
console.log(rawTx)
```

