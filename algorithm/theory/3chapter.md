최대 부분 배열 합

(배열에서 연속해 있는 값들을 택하여 최대인 부분 합을 구해내는것이 문제의 목표이다.)

O(n^3) 방식

a는 부분배열의 첫번째 부분을 의미함.
b는 부분배열의 마지막 부분을 의미함.
k를 움직이면서 부분 배열을 합하고, 매 배열이 끝날때 마다 best에 max값을 넣어서 가장ㅇ 큰 부분배열 합을 구한다.
```cpp
int best=0;
for(int a=0;i<n;a++){
    for(int b=a;b<n;b++){
        int sum=0;
        for(int k=a;k<=b;k++){
            sum+=array[k];
        }
        best=max(best,sum);
    }
}
```

O(n^2) 방식

a는 부분배열의 첫 지점을 의미하고
b가 움직이면서 합을 누적시킨다.
b가 연속으로 움직이면서 매번 가장 큰 부분배열을 구하는 것이다.
```cpp
int best=0;
for(int a=0;a<n;a++){
    int sum=0;
    for(int b=a;b<n;b++){
        sum+=array[b];
        best=max(best,sum);
    }
}
cout<<best<<"\n";
```

O(n) 방식 풀이

배열의 각 위치에 대해, 그 위치에서 끝나면서 합이 최대인 부분 배열을 계산한다.
" 그 위치에서 끝나는 " 합이 최대인 부분 배열을 찾는 것이다.

배열 위치 K에서 끝나면서, 합이 최대인 부분집합의 경우의 수

1. 부분배열 위치 k가 가장 크다.
2. k-1에서 끝나는 부분배열과 K를 합친 값이 가장크다.

이 2가지 경우가 나올 수 있다.

2번째 경우는, k-1에서 끝나는 부분배열의 합이, 최대여야 우리가 가정한 것이 성립하게된다.
배열을 왼쪽에서 오른쪽으로 진행시키며, 부분합을 기록하는 배열을 만들면 O(N)을 구할 수 있다.
```cpp
int best=0,sum=0;
for(int k=0;k<n;k++){
    sum=max(array[k],sum+array[k]); //sum 갱신
    best=max(best,sum);
}
```

2개의 퀸 문제
n*n 체스판에 2개의 퀸을 놓을 수 있는 방법을 묻는 문제이다.
브루트포스로 풀게되면 첫번째 퀸을 놓는대 n^2, 두번째 퀸을 놓는데 n^2이 걸리므로 O(n^4) 의 시간복잡도가 나온다.
효율적 알고리즘을 만들려면 경우의 수를 그룹 단위로 묶어서 세는 방법을 찾아야 한다.

한개의 퀸이 배치되면, 세로방향 n-1개, 가로방향 n-1개의 칸을 수직 수평으로 공격이 가능하다.
또한 대각선으로 d-1개 칸을 공격하는것도 가능하다. 양쪽방향으로 공격이 가능하다.

따라서 나머지 칸의 개수 n^2에서 위의 경우를 빼면 남는것이 퀸의 배치이므로 O(1)로 구할 수 있다.
따라서 최종적으로 O(n^2)으로 문제를 푸는것이 가능하다.

O(1)

점화식을 세워보자.
q(n)을 알고 있다면 q(n+1)을 구할 수 있는가?
q(n) => n*n 테이블에서 2개의 퀸을 놓을 수 있는 방법의 수
q(n+1)은 어떻게 알 수 있는가?

전제 
1. q(n+1)에서 마지막행과 열에 퀸을 배치하지 않는다면 그것이 q(n)이다.
2. 마지막 행과 열에 퀸을 배치할 수 있는 경우의 수는 2n+1이다. 왜냐하면 n+1 + n + 1 - 1 (중첩되는 부분 하나) 이기 때문이다.
3. 마지막 행과 열에 배치된 퀸이 공격할 수 있는 공격범위는 3(n)이다 . (가로 n, 세로 n 대각선 n)
4. 따라서 마지막 행과 열에 퀸이 배치되었을 경우 2번째 퀸이 배치될 수 있는 경우의 수는 (n+1)^2 -3n-1(자기자신) 이다.
5. 마지막으로 마지막 행과 열에 퀸 2개를 모두 배치할 수 있는 경우의 수는 n*n-1이다.
결론
q(n+1)=q(n)+(2n+1)*((n+1)^2-3n-1)-n*(n-1)이다.
```cpp

```